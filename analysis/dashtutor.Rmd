---
title: "Dirichlet adaptive shrinkage"
---

<!-- The file analysis/chunks.R contains chunks that define default settings
shared across the workflowr files. -->
```{r read-chunk, include=FALSE, cache=FALSE}
knitr::read_chunk("chunks.R")
```

<!-- Update knitr chunk options -->
```{r knitr-opts-chunk, include=FALSE}
```

<!-- Insert the date the file was last updated -->
```{r last-updated, echo=FALSE, results='asis'}
```

<!-- Insert the code version (Git commit SHA1) if Git repository exists and R
 package git2r is installed -->
```{r code-version, echo=FALSE, results='asis'}
```

<!-- Add your analysis here -->

Typically logo plots are used to represent the position weight matrix (PWM). However, the PWM is often generated from underlying position frequency matrix (PFM). PFM stores the compositional data - the frequencies of the symbols at each position. Given a PFM matrix however, we also have knowledge of the scale of the frequencies for each position. This additional information can be used to get a better logo plot representation compared to the usual PWM-based logo plots. 

Suppose for a specific position in a sequence, the compositional data is \[ (A, C, G, T) : = (6, 1, 2, 1) \] and in another case, it is \[ (A, C, G, T) : = (600, 100, 200, 100). \]. We assume that the background probability is equal for the four bases. If we transform the positional frequencies into PWM by taking the sample proportion, then the estimated PWM would be same for the two cases and would correspond to the same logo plot representation. However, in the second case, we have a total frequency of 1000 for all symbols while for the first case, it is only 10. Hence, it makes sense to shrink the PWM estimate to the background probability more strongly in the first case than that in the second case.

This is what we accomplish in an adaptive fashion using `dash` (Dirichlet Adaptive Shrinkage). We discuss the model formulation next. 

## Model formulation

Assume that there are \(L\) constituents in the compositional mix. \(L\) equals \(4\) (corresponding to A,C, G and T bases) for the DNa sequence motif data and \(20\) corresponding to the amino acids for the protein sequence data.

Suppose there are $L$ categories and $n$ positions. We model these compositional counts vectors as follows

\[ (c_{n1}, c_{n2}, \cdots, c_{nL}) \sim Mult \left ( c_{n+} : p_{n1}, p_{n2}, \cdots, p_{nL} \right ) \]

where \(c_{n+}\) is the total frequency of the different constituents of the compositional data observed for the \(n\) th base. \(p_{nl}\) here represents the compositional probability for the $l$ th base in the position $n$. We have

\[ p_{nl} >= 0 \hspace {1 cm} \sum_{l=1}^{L} p_{nl} = 1 \]

We choose the Dirichlet prior distribution on the compositional probability vector \((p_{n1}, p_{n2}, \cdots, p_{nL})\). In order to perform adaptive shrinkage, we assume a mixture of known Dirichlet priors, each having mean to be the background mean probability vector \( \mu_{1}, \mu_{2}, \cdots, \mu_{L} \), but with varying amounts of concentration, which need to be estimated along with the unknown mixture proportions from the data. \[ \left ( p_{n1}, p_{n2}, \cdots, p_{nL} \right ) : = \sum_{k=1}^{K} \pi_{k} Dir \left (\alpha_{k} \mu_{1}, \alpha_{k} \mu_{2}, \cdots, \alpha_{k} \mu_{L} \right ) \hspace {1 cm} \alpha_{k} > 0 \hspace{1 cm} \sum_{l=1}^{L} \mu_{l} = 1 \] 
We assume a prior of \(\pi_{k}\) to be Dirichlet

\[ f(\pi) : = \prod_{k=1}^{K} {\pi_{k}}^{\lambda_{k}-1} \]

## Default parameters

We choose a default set of \(\alpha_{k}\) to be \((Inf, 100, 50, 20, 10, 2, 1, 0.1, 0.01)\). In this case \(\alpha_{k}=Inf\) corresponds essentially to point mass at the prior mean or background mean \( \mu_{1}, \mu_{2}, \cdots, \mu_{L} \), and then the subsequent choices of \(\alpha_{k}\) have lower degree of concentration. $\alpha_{k} = 1$ corresponds to the most uniform scenario, whereas \(\alpha_{k} < 1\) correspond to cases with probability masses at the edges of the simplex but with the mean at the prior mean. The latter components would direct the points close to the corners towards the corners and away from the center, resulting in clearer separation of the points closer to the mean with the ones away from it.

We choose the default prior amount of shrinkage of \(\pi_{k}\), namely \(\lambda_{k}\) to be \(\left( 1, 1, 1, 1, \cdots, 1 \right )\). The user may want to increase the weight on the first term (corresponding to \( \alpha_{k} = Inf \)  ) to enforce stronger shrinkage. 

## Examples of dash 
  
We apply dash to PFMs with small, medium and high total frequencies($c_{n+}$). The total frequencies in the three cases are 5,20 and 114. Firstly, the logo plots are compared and then negative logo plot.

Logo plots:

```{r,message=FALSE,warning=FALSE,fig.height=7,fig.width=7}
library(Logolas)
library(grid)
library(dash)
pfm1=cbind(c(1,2,1,1),c(0,0,5,0),c(0,3,1,1),c(0,5,0,0),c(0,3,0,2),c(0,0,5,0),c(2,1,2,0),c(0,0,5,0),c(1,1,0,3))
pfm2=cbind(c(1,9,5,5),c(1,16,2,1),c(1,1,18,0),c(1,0,2,17),c(18,1,0,1),c(1,18,0,0),c(1,2,16,1),c(6,4,7,3),c(2,12,1,5),c(8,5,5,2))
pfm3=cbind(c(31,8,46,29),c(1,2,25,86),c(12,34,11,57),c(3,1,106,4),c(1,110,1,2),c(3,1,109,1),c(0,3,1,110),c(0,0,114,0),c(33,57,6,18))
rownames(pfm1)=c('A','C','G','T')
colnames(pfm1)=1:ncol(pfm1)
rownames(pfm2)=c('A','C','G','T')
colnames(pfm2)=1:ncol(pfm2)
rownames(pfm3)=c('A','C','G','T')
colnames(pfm3)=1:ncol(pfm3)

color_profile = list("type" = "per_row", 
                     "col" = RColorBrewer::brewer.pal(4,name ="Spectral"))

grid.newpage()
layout.rows <- 3
layout.cols <- 2
top.vp <- viewport(layout=grid.layout(layout.rows,layout.cols, widths=unit(rep(2,layout.cols), rep("null",layout.cols)),heights=unit(rep(2,1), rep("null",1))))

plot_reg <- vpList()
l <- 1
for(i in 1:layout.rows){
  for(j in 1:layout.cols){
    plot_reg[[l]] <- viewport(layout.pos.col = j, layout.pos.row = i, name = paste0("plotlogo", l))
    l <- l+1
  }
}


plot_tree <- vpTree(top.vp, plot_reg)

pushViewport(plot_tree)
seekViewport(paste0("plotlogo", 1))
logomaker(pfm1,
          color_profile = color_profile,
          frame_width = 1,
          newpage = F,
          yscale_change = F,
          pop_name = 'low freq',
          control = list(gap_xlab = 3))
seekViewport(paste0('plotlogo',2))
pfm1dash=dash(pfm1,optmethod = 'mixEM')$posmean
logomaker(pfm1dash,
          color_profile = color_profile,
          frame_width = 1,
          newpage=F,
          yscale_change = F,
          pop_name = 'low freq, dash',
          control = list(gap_xlab = 3))

seekViewport(paste0("plotlogo", 3))
logomaker(pfm2,
          color_profile = color_profile,
          frame_width = 1,
          newpage = F,
          yscale_change = F,
          pop_name = 'medium freq',
          control = list(gap_xlab = 3))
seekViewport(paste0('plotlogo',4))
pfm2dash=dash(pfm2,optmethod = 'mixEM')$posmean
logomaker(pfm2dash,
          color_profile = color_profile,
          frame_width = 1,
          newpage=F,
          yscale_change = F,
          pop_name = 'medium freq, dash',
          control = list(gap_xlab = 3))

seekViewport(paste0("plotlogo", 5))
logomaker(pfm3,
          color_profile = color_profile,
          frame_width = 1,
          newpage = F,
          yscale_change = F,
          pop_name = 'high freq',
          control = list(gap_xlab = 3))
seekViewport(paste0('plotlogo',6))
pfm3dash=dash(pfm3,optmethod = 'mixEM')$posmean

logomaker(pfm3dash,
          color_profile = color_profile,
          frame_width = 1,
          newpage=F,
          yscale_change = F,
          pop_name = 'high freq, dash',
          control = list(gap_xlab = 3))

```

The corresponding negative Logolas plots are given below.

```{r,message=FALSE,warning=FALSE,fig.height=7,fig.width=7}

grid.newpage()
layout.rows <- 3
layout.cols <- 2
top.vp <- viewport(layout=grid.layout(layout.rows,layout.cols, widths=unit(rep(2,layout.cols), rep("null",layout.cols)),heights=unit(rep(2,1), rep("null",1))))

plot_reg <- vpList()
l <- 1
for(i in 1:layout.rows){
  for(j in 1:layout.cols){
    plot_reg[[l]] <- viewport(layout.pos.col = j, layout.pos.row = i, name = paste0("plotlogo", l))
    l <- l+1
  }
}


plot_tree <- vpTree(top.vp, plot_reg)

pushViewport(plot_tree)
seekViewport(paste0("plotlogo", 1))
nlogomaker(pfm1,
           logoheight = 'log_odds',
          color_profile = color_profile,
          frame_width = 1,
          newpage = F,
          pop_name = 'low freq',
          control = list(gap_xlab = 3, gap_ylab = 3.5))

seekViewport(paste0('plotlogo',2))
pfm1dash=dash(pfm1,optmethod = 'mixEM')$posmean

nlogomaker(pfm1dash,
          logoheight = 'log_odds',
          color_profile = color_profile,
          frame_width = 1,
          newpage=F,
          pop_name = 'low freq, dash',
          control = list(gap_xlab = 3, gap_ylab = 3.5))

seekViewport(paste0("plotlogo", 3))
nlogomaker(pfm2,
           logoheight = 'log_odds',
          color_profile = color_profile,
          frame_width = 1,
          newpage = F,
          pop_name = 'medium freq',
          control = list(gap_xlab = 3, gap_ylab = 3.5))
seekViewport(paste0('plotlogo',4))
pfm2dash=dash(pfm2,optmethod = 'mixEM')$posmean

nlogomaker(pfm2dash,
          color_profile = color_profile,
          logoheight = 'log_odds',
          frame_width = 1,
          newpage=F,
          pop_name = 'medium freq, dash',
          control = list(gap_xlab = 3, gap_ylab = 3.5))

seekViewport(paste0("plotlogo", 5))
nlogomaker(pfm3,
           logoheight = 'log_odds',
          color_profile = color_profile,
          frame_width = 1,
          newpage = F,
          pop_name = 'high freq',
          control = list(gap_xlab = 3, gap_ylab = 3.5))
seekViewport(paste0('plotlogo',6))
pfm3dash=dash(pfm3,optmethod = 'mixEM')$posmean

nlogomaker(pfm3dash,
           logoheight = 'log_odds',
          color_profile = color_profile,
          frame_width = 1,
          newpage=F,
          pop_name = 'high freq, dash',
          control = list(gap_xlab = 3, gap_ylab = 3.5))

```

## Dash and background probability 

The default background probability is uniform for each compositional class. User could also specify the background probability in the functions including `dash`,`logomaker`,`nlogomaker`.

Here, we present the comparisons of logo plots and negative logo plots from 4 different PWMs of one PFM generated in the following way:

- uniform background probability for all positions + no dash 
- uniform background probability for all positions + dash
- non-uniform and specified background probability + no dash 
- non-uniform and specified background probability + dash 


```{r,message=FALSE,warning=FALSE,fig.height=7,fig.width=7}
bg=c(0.3141, 0.1859, 0.1859, 0.3141)
grid.newpage()
layout.rows <- 2
layout.cols <- 2
top.vp <- viewport(layout=grid.layout(layout.rows,layout.cols, widths=unit(rep(2,layout.cols), rep("null",layout.cols)),heights=unit(rep(2,1), rep("null",1))))

plot_reg <- vpList()
l <- 1
for(i in 1:layout.rows){
  for(j in 1:layout.cols){
    plot_reg[[l]] <- viewport(layout.pos.col = j, layout.pos.row = i, name = paste0("plotlogo", l))
    l <- l+1
  }
}


plot_tree <- vpTree(top.vp, plot_reg)

pushViewport(plot_tree)
seekViewport(paste0("plotlogo", 1))
logomaker(pfm2,
          color_profile = color_profile,
          frame_width = 1,
          newpage = F,
          yscale_change = F,
          pop_name = 'same bg, no dash',
          control = list(gap_xlab = 3))

seekViewport(paste0("plotlogo", 2))
logomaker(pfm2dash,
          color_profile = color_profile,
          frame_width = 1,
          newpage = F,
          yscale_change = F,
          pop_name = 'same bg, dash',
          control = list(gap_xlab = 3))


seekViewport(paste0("plotlogo", 3))
logomaker(pfm2,
          bg=bg,
          color_profile = color_profile,
          frame_width = 1,
          newpage = F,
          yscale_change = F,
          pop_name = 'varying bg, no dash',
          control = list(gap_xlab = 3))

pfm2dashbg=dash(pfm2,optmethod = 'mixEM',mode = bg)$posmean

seekViewport(paste0("plotlogo", 4))
logomaker(pfm2dashbg,
          bg=bg,
          color_profile = color_profile,
          frame_width = 1,
          newpage = F,
          yscale_change = F,
          pop_name = 'varying bg, dash',
          control = list(gap_xlab = 3))

```

Negative logo plots:

```{r,message=FALSE,warning=FALSE,fig.height=7,fig.width=7}
grid.newpage()
layout.rows <- 2
layout.cols <- 2
# top.vp <- viewport(layout=grid.layout(layout.rows,layout.cols, widths=unit(rep(2,layout.cols), rep("null",layout.cols)),heights=unit(rep(2,1), rep("null",1))))

top.vp <- viewport(layout=grid.layout(layout.rows, layout.cols,
                                      widths=unit(rep(6,layout.cols), rep("null", 2)),
                                      heights=unit(c(15,15), rep("lines", 2))))
plot_reg <- vpList()
l <- 1
for(i in 1:layout.rows){
  for(j in 1:layout.cols){
    plot_reg[[l]] <- viewport(layout.pos.col = j, layout.pos.row = i, name = paste0("plotlogo", l))
    l <- l+1
  }
}


plot_tree <- vpTree(top.vp, plot_reg)

pushViewport(plot_tree)
seekViewport(paste0("plotlogo", 1))
nlogomaker(pfm2,
           logoheight = 'log_odds',
          color_profile = color_profile,
          frame_width = 1,
          newpage = F,
          pop_name = 'same bg, no dash',
          control = list(gap_xlab = 3, gap_ylab = 3.5))

seekViewport(paste0("plotlogo", 2))
nlogomaker(pfm2dash,
           logoheight = 'log_odds',
          color_profile = color_profile,
          frame_width = 1,
          newpage = F,
          pop_name = 'same bg, dash',
          control = list(gap_xlab = 3, gap_ylab = 3.5))


seekViewport(paste0("plotlogo", 3))
nlogomaker(pfm2,
           logoheight = 'log_odds',
          bg=bg,
          color_profile = color_profile,
          frame_width = 1,
          newpage = F,
          pop_name = 'varying bg, no dash',
          control = list(gap_xlab = 3, gap_ylab = 3.5))

pfm2dashbg=dash(pfm2,optmethod = 'mixEM',mode = bg)$posmean

seekViewport(paste0("plotlogo", 4))
nlogomaker(pfm2dashbg,
           logoheight = 'log_odds',
          bg=bg,
          color_profile = color_profile,
          frame_width = 1,
          newpage = F,
          pop_name = 'varying bg, dash',
          control = list(gap_xlab = 3, gap_ylab = 3.5))

```

## Session information

<!-- Insert the session information into the document -->
```{r session-info}
```
